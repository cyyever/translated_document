# The Google File System
#### Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung<br/><center>google*</center>

*：这些作者可以通过以下地址联系：{sanjay,hgobioff,shuntak}@google.com

# 摘要（ABSTRACT）

我们设计并实现了Google文件系统，一个可扩展的分布式文件系统，用于大型的数据密集型的分布式应用程序。它运行于不昂贵的硬件上，但提供了容错性，并且它可以提供了高的整体性能（aggregate performance）给大量的客户端。虽然GFS有很多目标和以前的分布式文件系统一样，我们根据对（当前和预计的）应用程序工作负载（workload）和技术环境的观察来引导GFS的设计，这些观察反映我们的设计不同于和以前一些对文件系统的假设。这导致我们重新审视传统的设计选项并探索完全不同的设计要点。

由此产生的文件系统成功地满足了我们的存储需求。它在Google内部被广泛部署，我们那些需要大数据集的服务或研究和开发工作把作为存储平台来生成和处理数据。其中最大的数据集群提供了数百TB的存储能力，这些存储能力由超过一千台机器上的数千个硬盘提供，并且该集群被数百个客户端并发访问。

在本论文里我们提供了为了支持分布式应用而设计的文件系统接口的扩展，从许多方面讨论了我们设计，同时报告了来自于微型基准测试和真实场景的测量结果。
 
# 分类和主题描述符（Categories and Subject Descriptors）
D [4]: 3—分布式文件系统

# 概括术语（General Terms）
设计，可靠性，性能，测量（Design, reliability, performance, measurement）

# 关键词（General Terms）
容错性，可扩展性，数据存储，集群存储（Fault tolerance, scalability, data storage, clustered storage）

## 1. 介绍（INTRODUCTION）
我们设计并实现了Google文件系统(GFS)来满足Google急剧增长的数据处理需求。GFS有很多目标和以前的分布式文件系统一样，例如性能，可扩展性，可靠性和可用性。但是它的设计是根据我们对（当前和预计的）应用程序工作负载（workload）和技术环境的观察来引导的，这些观察反映我们的设计不同于和以前一些对文件系统的设计假设。我们重新审视了传统的设计选项并探索了完全不同的设计要点。

首先，组件的故障是常态而非意外。GFS文件系统包含数百以至数千的由不昂贵的零件组成的存储机器，并且被这些数量级的客户端机器访问。组件的质量和数量事实上导致了在任意给定的时间点总有一些机器出现功能故障并且有一些机器无法从当前的故障中恢复。我们碰到过应用程序BUG，操作系统BUG, 人类错误和磁盘，内存，连接器（connector）和电力供应的故障所导致的问题。因此，持续地监控，错误检测，容错性和自动恢复必须集成到文件系统里。
 
第二，按照传统的标准，我们所涉及的文件是超大文件。几GB的文件是家常便饭。每个文件通常包含许多的程序对象，例如web文档。当我们例行要处理的是快速增长的许多TB的数据集（包含若干亿的程序对象）时，就算是文件系统提供支持，我们也难以有效管理若干亿只有kb大小的文件。
因此，文件系统的设计假定和参数，例如I/O操作和块大小（block size），必须被重新审视。

第三，大多数文件是通过添加（append）新数据而非覆写已有数据来进行修改的。在文件内的随机写几乎是不存在的。一旦写入完毕，文件只被读取，而且经常只被顺序读取。许多类型的数据都有这些特征。有些可能构成大数据仓库以便数据分析程序进行扫描。有些可能是由运行中的程序持续生成的数据流。有些可能是归档数据。有些可能是一台机器产生的中间结果，并同时或者以后被另一台机器处理。由于该超大文件的访问模式，添加（appending）成为了性能优化和原子性保证所关注的焦点，与此同时在客户端缓存数据块的方案不再具有吸引力。

第四，协设计（co-designing）应用程序和文件系统API可以增加我们的灵活性，使得整体系统受益。例如，我们放宽了GFS的一致性模型，这样大大简化了文件系统，但却没有给应用程序增加繁重的负担。我们还引入了一个原子添加的操作以便多个客户端可以并发地添加同一个文件，而不需要在它们之间做额外的同步。我们将在论文后面更详细地讨论这些东西。

目前我们部署了多个GFS集群，用于不同的目的。其中最大的集群拥有超过1000个存储节点，超过300TB的硬盘存储，并且被不同机器上的数百个客户端持续地，繁忙地访问。
